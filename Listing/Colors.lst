C51 COMPILER V9.02   COLORS                                                                04/21/2018 17:36:46 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE COLORS
OBJECT MODULE PLACED IN ..\Output\Colors.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\Code\DirverCode\Colors.C BROWSE INCDIR(..\Code\DeveloperCode\inc;..\Code
                    -\DirverCode\inc;..\Code\Public\inc) DEBUG OBJECTEXTEND PRINT(..\Listing\Colors.lst) OBJECT(..\Output\Colors.obj)

line level    source

   1          /* *******************************************************************************************
   2          // Author: biu~
   3          // Last Date:2018/04/20
   4          /* ******************************************************************************************* */
   5          #include "Colors.H"
   6          
   7          #define PWM_DUTY_MAX    255 // 0~255    PWM周期, 最大255
   8          #define PWM_ON          0   // 定义占空比的电平, 1 或 0
   9          #define PWM_OFF         (!PWM_ON)
  10          
  11          #define PWM_BLUE    0
  12          #define PWM_GREEN   1
  13          #define PWM_RED     2
  14          
  15          #define PWM_ACCELERATE1 0xA0
  16          #define PWM_ACCELERATE2 0xC7
  17          sbit Color_Blue = P3^1;
  18          sbit Color_Green = P3^2;
  19          sbit Color_Red = P3^3;
  20          data u8 PwmDuty[3];
  21          /* *******************************************************************************************
  22          // 定时器PWM输出初始化：
  23          /* ******************************************************************************************* */
  24          void TimerPWM_Init()
  25          {
  26   1          PwmDuty[PWM_BLUE] = 0x00;
  27   1          PwmDuty[PWM_GREEN] = 0x00;
  28   1          PwmDuty[PWM_RED] = 0x00;
  29   1      }
  30                    
  31          /* *******************************************************************************************
  32          // 定时器控制PWM输出 
  33          /* ******************************************************************************************* */
  34          void TimerPWM()
  35          {
  36   1          static idata u8 temp_pwm_duty = 0;
  37   1          if(temp_pwm_duty == PwmDuty[PWM_BLUE]) Color_Blue = PWM_OFF;       //判断PWM占空比是否结束
  38   1          if(temp_pwm_duty == PwmDuty[PWM_GREEN]) Color_Green = PWM_OFF;
  39   1          if(temp_pwm_duty == PwmDuty[PWM_RED]) Color_Red = PWM_OFF;
  40   1              
  41   1          if(++temp_pwm_duty == PWM_DUTY_MAX)                 //PWM周期结束，重新开始新的周期
  42   1          {
  43   2              temp_pwm_duty = 0;
  44   2              if (PwmDuty[PWM_BLUE] != 0)                     //在PWM占空为0时不开启灯光；
  45   2                  Color_Blue = PWM_ON;
  46   2              if (PwmDuty[PWM_GREEN] != 0)
  47   2                  Color_Green = PWM_ON;
  48   2              if (PwmDuty[PWM_RED] != 0)
  49   2                  Color_Red = PWM_ON;
  50   2          }
  51   1      }
  52          
  53          /* *******************************************************************************************
  54          // PWM占空改变功能函数：某_bit（颜色）占空比增加至 temp_pwm
C51 COMPILER V9.02   COLORS                                                                04/21/2018 17:36:46 PAGE 2   

  55          /* ******************************************************************************************* */
  56          bit TimerPWM_Duty_Add(u8 _bit, u8 temp_pwm)
  57          {
  58   1          if (temp_pwm > PwmDuty[_bit])
  59   1          {
  60   2              if (PwmDuty[_bit] >= PWM_ACCELERATE2 && PwmDuty[_bit] < 0xFD)   //亮度较高时，由于人眼对较亮的灯光
             -亮度改变感受不明显，进行加速处理；
  61   2              {
  62   3                  PwmDuty[_bit] += 3;
  63   3              }
  64   2              else if (PwmDuty[_bit] >= PWM_ACCELERATE1 && PwmDuty[_bit] < 0xFE)
  65   2              {
  66   3                  PwmDuty[_bit] += 2;
  67   3              }
  68   2              else
  69   2              {
  70   3                  PwmDuty[_bit] ++;
  71   3              }
  72   2          }  
  73   1          else 
  74   1          {
  75   2              return 1;
  76   2          }  
  77   1          return 0;
  78   1      }
  79          
  80          /* *******************************************************************************************
  81          // PWM占空改变功能函数：某_bit（颜色）占空比减至 temp_pwm
  82          /* ******************************************************************************************* */
  83          bit TimerPWM_Duty_Dec(u8 _bit, u8 temp_pwm)
  84          {
  85   1          if (temp_pwm < PwmDuty[_bit])
  86   1          {
  87   2              if (PwmDuty >= PWM_ACCELERATE2) //亮度较高时，由于人眼对较亮的灯光亮度改变感受不明显，进行加速处理
             -；
  88   2              {
  89   3                  PwmDuty[_bit] -= 3;
  90   3              }
  91   2              else if (PwmDuty[_bit] >= PWM_ACCELERATE1)
  92   2              {
  93   3                  PwmDuty[_bit] -= 2;
  94   3              }
  95   2              else
  96   2              {
  97   3                  PwmDuty[_bit] --;
  98   3              }
  99   2          }
 100   1          else 
 101   1          {
 102   2              return 1;
 103   2          }  
 104   1          return 0;
 105   1      }
 106          
 107          #define DEC 0
 108          #define ADD 1
 109          
 110          #define BLUE_RED    1
 111          #define BLUE_GREEN  2
 112          #define RED_GREEN   3
 113          /* *******************************************************************************************
 114          // 多（双）颜色亮度控制
C51 COMPILER V9.02   COLORS                                                                04/21/2018 17:36:46 PAGE 3   

 115          /* ******************************************************************************************* */
 116          static bit conColorsPWM(u8 colors, bit color1_dec_or_inc, u8 temp_color1, bit color2_dec_or_inc, u8 temp_c
             -olor2)
 117          {
 118   1          auto u8 count = 0;
 119   1          switch (colors)
 120   1          {
 121   2              case BLUE_RED:
 122   2              {
 123   3                  if ((color1_dec_or_inc == DEC) ? TimerPWM_Duty_Dec(PWM_BLUE, temp_color1) : TimerPWM_Duty_Add(
             -PWM_BLUE, temp_color1))
 124   3                  {
 125   4                      count ++;
 126   4                  }
 127   3                  if ((color2_dec_or_inc == DEC) ? TimerPWM_Duty_Dec(PWM_RED, temp_color2) : TimerPWM_Duty_Add(P
             -WM_RED, temp_color2))
 128   3                  {
 129   4                      count ++;
 130   4                  }
 131   3              }
 132   2                  break;
 133   2              case BLUE_GREEN:
 134   2              {
 135   3                  if ((color1_dec_or_inc == DEC) ? TimerPWM_Duty_Dec(PWM_BLUE, temp_color1) : TimerPWM_Duty_Add(
             -PWM_BLUE, temp_color1))
 136   3                  {
 137   4                      count ++;
 138   4                  }
 139   3                  if ((color2_dec_or_inc == DEC) ? TimerPWM_Duty_Dec(PWM_GREEN, temp_color2) : TimerPWM_Duty_Add
             -(PWM_GREEN, temp_color2))
 140   3                  {
 141   4                      count ++;
 142   4                  }
 143   3              }
 144   2                  break;
 145   2              case RED_GREEN:
 146   2              {
 147   3                  if ((color1_dec_or_inc == DEC) ? TimerPWM_Duty_Dec(PWM_RED, temp_color1) : TimerPWM_Duty_Add(P
             -WM_RED, temp_color1))
 148   3                  {
 149   4                      count ++;
 150   4                  }
 151   3                  if ((color2_dec_or_inc == DEC) ? TimerPWM_Duty_Dec(PWM_GREEN, temp_color2) : TimerPWM_Duty_Add
             -(PWM_GREEN, temp_color2))
 152   3                  {
 153   4                      count ++;
 154   4                  }
 155   3              }
 156   2                  break;
 157   2              default:
 158   2                  break;
 159   2          }
 160   1          return ((count == 2) ? 1 : 0);
 161   1      }
 162          
 163          /* *******************************************************************************************
 164          // 所有颜色渐熄
 165          /* ******************************************************************************************* */
 166          static bit conAllColorsOff()
 167          {
 168   1          auto u8 count = 0;
 169   1          if (TimerPWM_Duty_Dec(PWM_BLUE, 0))
C51 COMPILER V9.02   COLORS                                                                04/21/2018 17:36:46 PAGE 4   

 170   1          {
 171   2              count ++;
 172   2          }
 173   1          if (TimerPWM_Duty_Dec(PWM_GREEN, 0))
 174   1          {
 175   2              count ++;
 176   2          }
 177   1          if (TimerPWM_Duty_Dec(PWM_RED, 0))
 178   1          {
 179   2              count ++;
 180   2          }
 181   1          return ((count == 3) ? 1 : 0);
 182   1      }
 183          
 184          #define SLOW 0
 185          #define FAST 1
 186          
 187          bit conSpeed = SLOW;
 188          /* *******************************************************************************************
 189          // PWM占空比改变控制：慢速
 190          /* ******************************************************************************************* */
 191          void Con_TimerPWM_Duty_Slow()
 192          {
 193   1          static u8 mode = 0;         //当前模式；
 194   1          if (conSpeed == SLOW)
 195   1          {
 196   2              switch (mode)
 197   2              {
 198   3      //            case 0: if(TimerPWM_Duty_Add(PWM_BLUE, 255) == 1) {mode ++;}
 199   3                  case 0: if(TimerPWM_Duty_Add(PWM_BLUE, 255)) {mode ++;}
 200   3                      break; 
 201   3                  case 1: if(TimerPWM_Duty_Dec(PWM_BLUE, 0)) {mode ++;}
 202   3                      break;
 203   3                  case 2: if(TimerPWM_Duty_Add(PWM_RED, 255)) {mode ++;}
 204   3                      break;
 205   3                  case 3: if(TimerPWM_Duty_Dec(PWM_RED, 80)) {mode ++; conSpeed = FAST;}
 206   3                      break;
 207   3      #define BLUE_RED    1
 208   3      #define BLUE_GREEN  2
 209   3      #define RED_GREEN   3
 210   3      #define DEC 0
 211   3      #define ADD 1
 212   3                  case 4: if(conColorsPWM(BLUE_RED, ADD, 120, ADD, 200)) {mode ++;} 
 213   3                      break;
 214   3                  case 5: if(conColorsPWM(BLUE_RED, ADD, 230, ADD, 255)) {mode ++;}
 215   3                      break;
 216   3                  case 6: if (conAllColorsOff()) {mode ++;}
 217   3                      break;                                                                                    
             -                  
 218   3                  case 7: if(conColorsPWM(BLUE_GREEN, ADD, 50, ADD, 230)) {mode ++;}
 219   3                      break;
 220   3                  case 8: if(conColorsPWM(RED_GREEN, ADD, 255, DEC, 0)) {mode ++;}
 221   3                      break;
 222   3                  case 9: if(conAllColorsOff()) {mode ++; conSpeed = FAST;}
 223   3                      break;
 224   3                  case 10: if(conColorsPWM(BLUE_RED, ADD, 80, ADD, 200)) {mode ++;}
 225   3                      break;
 226   3                  case 11: if(conColorsPWM(BLUE_RED, ADD, 230, ADD, 255)) {mode ++;}
 227   3                      break;
 228   3                  case 12: if(conAllColorsOff()) {mode ++;}
 229   3                      break;
 230   3                  case 13: if(conColorsPWM(RED_GREEN, ADD, 20, ADD, 255)) {mode ++;}
C51 COMPILER V9.02   COLORS                                                                04/21/2018 17:36:46 PAGE 5   

 231   3                      break;
 232   3                  case 14: if(conAllColorsOff()) {mode ++;}
 233   3                      break;
 234   3                  case 15: if(conColorsPWM(BLUE_GREEN, ADD, 50, ADD, 230)) {mode ++; conSpeed = FAST;}
 235   3                      break;
 236   3                  default:if(conAllColorsOff()) {mode = 0;}
 237   3                      break;
 238   3              }
 239   2          }
 240   1      }
 241          
 242          /* *******************************************************************************************
 243          // PWM占空比改变控制：快速
 244          /* ******************************************************************************************* */
 245          void Con_TimerPWM_Duty_Fast()
 246          {
 247   1          static u8 mode = 0;         //当前模式；
 248   1          if (conSpeed == FAST)
 249   1          {
 250   2              switch (mode)
 251   2              {
 252   3                  case 0: if(TimerPWM_Duty_Add(PWM_GREEN, 255)) {mode ++;}
 253   3                      break;
 254   3                  case 1: if(TimerPWM_Duty_Dec(PWM_GREEN, 120)) {mode ++;}
 255   3                      break;
 256   3                  case 2: if(TimerPWM_Duty_Add(PWM_BLUE, 60)) {mode ++;}
 257   3                      break;
 258   3                  case 3: if(conColorsPWM(BLUE_GREEN, DEC, 0, ADD, 90)) {mode ++;}
 259   3                      break;
 260   3                  case 4: if(conColorsPWM(RED_GREEN, ADD, 255, ADD, 240)) {mode ++;}
 261   3                      break;
 262   3                  case 5: if(conColorsPWM(RED_GREEN, DEC, 230, DEC, 140)) {mode ++;}
 263   3                      break;
 264   3                  case 6: if(conColorsPWM(BLUE_GREEN, ADD, 255, ADD, 230)) {mode ++;}
 265   3                      break;
 266   3                  case 7: if(conAllColorsOff()) {mode ++; conSpeed = SLOW;}
 267   3                      break;
 268   3                  case 8: if(TimerPWM_Duty_Add(PWM_RED, 255)) {mode ++;}
 269   3                      break;
 270   3                  case 9: if(conColorsPWM(BLUE_RED, ADD, 255, DEC, 120)) {mode ++;}
 271   3                      break;
 272   3                  case 10: if(TimerPWM_Duty_Dec(PWM_BLUE, 180)) {mode ++;}
 273   3                      break;
 274   3                  case 11: if(conColorsPWM(BLUE_GREEN, DEC, 180, ADD, 255)) {mode ++; conSpeed = SLOW;}
 275   3                      break;
 276   3                  default:if(conAllColorsOff()) {mode = 0;}
 277   3                      break;
 278   3              }
 279   2          }
 280   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    920    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       3
   IDATA SIZE       =      1    ----
   BIT SIZE         =      1       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
